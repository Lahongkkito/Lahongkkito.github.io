{"meta":{"title":"MJ's Study Note blog","subtitle":"Python & Machine Learning study blog","description":null,"author":"Lahongkkito","url":"https://Lahongkkito.github.io","root":"/"},"pages":[],"posts":[{"title":"basic","slug":"basic","date":"2019-10-06T12:43:22.000Z","updated":"2019-10-06T13:07:58.041Z","comments":true,"path":"2019/10/06/basic/","link":"","permalink":"https://Lahongkkito.github.io/2019/10/06/basic/","excerpt":"","text":"Numpy N차원 배열 객체 파이썬으로 수치해석, 통계 관련 기능 구현시 가장 기본이 되는 모듈 유용한 선형 대수학, 푸리에 변환 및 난수 기능 등을 빠르게 계산하기 위한 패키지 (대부분의 데이터는 행렬 형태) 범용적 데이터 처리에 사용 가능한 다차원 컨테이너 C,C++,Fortran로 작성되어 실행 속도 빠름 Scipy, Pandas, matplotlib 등의 기반으로 사용 사용1import numpy as np 입출력 배열 객체를 바이너리 파일 혹은 텍스트 파일에 저장, 로딩 기능 제공 np.save(): NumPy 배열 객체 1개를 파일에 저장, 확장자: npy np.savez(): NumPy 배열 객체 복수개를 1게 파일에 저장, 확장자: pnz np.load() : NumPy 배열 저장 파일로 부터 객체 로딩 np.loadtxt() : 텍스트 파일로 부터 배열 로딩 fname: 파일명 dtype: 데이터 타입 comments: comment 시작 부호 delimiter: 구분자 skiprows: 제외 라인 수(header 제거용) 텍스트를 포함한 파일이 경우 dtyped으로 컬럼 명과 데이터 타입을 설정해야 합니다. np.savetxt() : 텍스트 파일에 NumPy 배열 객체 저장 Numpy 데이터 타입 np.int64 : 64 비트 정수 타입 np.float32 : 32 비트 부동 소수 타입 np.complex : 복소수 (128 float) np.bool : 불린 타입 (Trur, False) np.object : 파이썬 객체 타입 np.string_ : 고정자리 스트링 타입 np.unicode_ : 고정자리 유니코드 타입 도움말 np.info()","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"},{"name":"Numpy","slug":"Python/Numpy","permalink":"https://Lahongkkito.github.io/categories/Python/Numpy/"}],"tags":[]},{"title":"06-2_Operating System","slug":"06-2-Operating-System","date":"2019-10-02T11:37:30.000Z","updated":"2019-10-06T03:40:16.493Z","comments":true,"path":"2019/10/02/06-2-Operating-System/","link":"","permalink":"https://Lahongkkito.github.io/2019/10/02/06-2-Operating-System/","excerpt":"","text":"OS/Shutil Module OS: 운영체제와 관련된 함수와 클래스를 제공하는 라이브러리 shutil: 파일, 폴더와 관련된 함수와 클래스를 제공하는 라이브러리 12import osimport shutil 디렉토리 만들기os.makedirs(&#39;폴더명&#39;) 디렉토리내 파일 리스트 불러오기os.listdir(&#39;폴더명&#39;) 파일 삭제os.remove(&#39;폴더명/파일명&#39;) 디렉토리 삭제 (파일이 존재하지 않는 경우에만)os.removedirs(&#39;폴더명&#39;) 파일과 디렉토리 삭제shutil.rmtree(&#39;폴더명&#39;) 파일(폴더) 존재 확인os.path.exists(&#39;폴더명/파일명&#39;) 디렉토리 타입 확인os.path.isdir(&#39;폴더명/파일명&#39;) 현재 디렉토리 확인os.curdir 부모 디렉토리 확인os.pardir 복사shutil.copy(&#39;폴더명/파일명&#39;) 파일명 바꾸기os.rename(&#39;폴더명/기존파일명&#39;, &#39;폴더명/새파일명&#39;) 권한설정 -rwxr–r– : 10개의 문자로 이루어진 파일 권한에 관한 정보 [0] : 타입 [1:4] : 소유자에 대한 파일의 권한 [4:7] : 그룹에 대한 파일의 권한 [7:] : 모든 사용자에 대한 파일의 권한 권한 : rwx r : 읽기 권한 w : 쓰기 권한 x : 실행 권한 권한 설정 : 2진수(권한 있으면 1, 없으면 0), 8진수 chmod 명령 이용os.chmod(&#39;폴더명/파일명&#39;, 권한) 7(8) : 111(2) : rwx 5(8) : 101(2) : r-x 권한 확인 os.F_OK : 파일 자체가 존재하는 지 확인 os.R_OK : 읽기 권한이 있는 지 확인 os.W_OK : 쓰기 권한이 있는 지 확인 os.R_OK : 실행 권한이 있는 지 확인 os.access(&#39;폴더명/파일명&#39;, 권한)","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"os","slug":"os","permalink":"https://Lahongkkito.github.io/tags/os/"},{"name":"rwx","slug":"rwx","permalink":"https://Lahongkkito.github.io/tags/rwx/"},{"name":"shutil","slug":"shutil","permalink":"https://Lahongkkito.github.io/tags/shutil/"}]},{"title":"09_InputOutput","slug":"09-InputOutput","date":"2019-09-30T05:35:09.000Z","updated":"2019-10-06T03:41:26.193Z","comments":true,"path":"2019/09/30/09-InputOutput/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/30/09-InputOutput/","excerpt":"","text":"File 파일을 통한 입출력 방법 파일 생성파일 객체 = open(폴더/파일명, 열기 모드) 파일 읽기, 쓰기 x : 파일 쓰기 (존재하지 않을 때만 생성) w : 파일 쓰기 (덮어쓰기) r : 파일 읽기 a : 파일 마지막에 새로운 내용 추가 파일 타입 t : 텍스트 타입 b : 이진 타입 텍스트 파일 작성 12text1 = \"\"\"Autumn...the year's last, loveliest smile.\"\"\" 텍스트 파일 쓰기 123f = open(\"sample1.txt\", \"wt\")f.write(text1)f.close() 텍스트 파일 읽기 1234f = open(\"sample1.txt\", \"rt\")s1 = f.read()f.close()print(s1) 12Autumn...the year&apos;s last, loveliest smile. 바이너리 파일 작성 1bin1 = bytes(range(6, 10)) 바이너리 파일 쓰기 123f = open(\"sample2.b\", \"wb\")f.write(bin1)f.close() 바이너리 파일 읽기 1234f = open(\"sample2.b\", \"rb\")s2 = f.read()f.close()print(list(s2)) 1[6, 7, 8, 9] readline(s) 함수 readline() : 파일.txt의 가장 첫 번째 줄이 화면에 출력 readlines() : 파일의 모든 줄을 읽어서 각각의 줄을 요소로 갖는 리스트로 출력 read() : 파일의 내용 전체를 문자열로 출력 123456f = open(\"test/sample1.txt\", \"rt\")line = f.readline()#lines = f.readlines()f.close()print(line)#print(lines) 12Autumn...#['Autumn...\\n', \"the year's last, loveliest smile.\"] with문 with 블록을 벗어나는 순감 열린 파일 객체 자동 close 12with open(\"test/sample3.txt\", \"w\") as f: f.write(\"Autumn is a second spring when every leaf a flower.\") Pickle 데이터가 아닌 파이썬 객체 자체를 파일로 저장/로딩 리스트, 클래스 등의 비텍스트 자료형 저장에 이용 바이너리로 저장되어 저용량 한 개 파일에 dump 함수를 여러번 실행하여 여러 객체 저장dump(object, file, protocol) 여러 객체가 저장된 pkl파일에 load를 여러번 실행하여 객체 로딩load(file) 123456789101112131415import pickleimport gzip # 압축 및 해제 프로그램 data = &#123; 'a': ['cucumber', 'daikon', 'onion'], 'b': &#123;True, False, None&#125;&#125;# save and compress.with gzip.open('test/PickleFile.pkl', 'wb') as f: pickle.dump(data, f)# load and uncompress.with gzip.open('test/PickleFile.pkl','rb') as f: data = pickle.load(f)","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"pickle","slug":"pickle","permalink":"https://Lahongkkito.github.io/tags/pickle/"}]},{"title":"08_Regex","slug":"08-Regex","date":"2019-09-26T23:28:15.000Z","updated":"2019-10-06T03:41:15.331Z","comments":true,"path":"2019/09/27/08-Regex/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/27/08-Regex/","excerpt":"","text":"정규표현식 regular expression 특정 패턴과 일치하는 문자열을 검색, 치환, 제거하는 기능 지원 raw string : 문자열 앞에 r이 붙으면 구성된 그대로 문자열로 변환 12345a = 'abcdef\\n' # escapce 문자열print(a)b = r'abcdef\\n'print(b) 12abcdefabcdef\\n pattern 기본 패턴 \\가 붙으면 스페셜한 의미가 없어짐 \\d : 숫자 (\\D: 숫자 외) \\w : 숫자, 문자, _ (\\W : 문자, 숫자, _ 외) \\s : 공백문자 (\\S : 공백문자 외) \\t, \\n, \\r : tab, newline, return metacharacters (지정자) [] : 문자 묶음, 내부의 메타 캐릭터 자체를 나타냄 [abck] : a or b or c or k [abc.^] : a or b or c or . or ^ [0-9] : 모든 숫자 [a-z] : 모든 소문자 [A-Z] : 모든 대문자 [a-zA-Z0-9] : 모든 알파벳 문자 및 숫자 반복패턴 반복 패턴의 경우 greedy하게 검색 함, 즉 가능한 많은 부분이 매칭되도록 함 ^ : 문자열의 시작 $ : 문자열의 끝 - : 범위 . : 어떤 하나의 문자 ? : 0~1회 * : 0회 이상 + : 1회 이상 {m} : m회 {m, n} : m~n회 반복({m,n}?로 사용하면 최소 m번만 매칭하면 만족) () : 그룹핑 1234m = re.search(r'(\\w+)@(.+)', 'lahongkkito@gmail.com')print(m.group(1))print(m.group(2))print(m.group(0)) 123lahongkkitogmail.comlahongkkito@gmail.com 정규표현식 함수 패턴을 찾지 못하면 None 반환 match 주어진 문자열의 시작부터 비교하여 패턴이 있는지 확인 시작부터 해당 패턴이 존재하지 않다면 None 반환 search와 유사 search : 문자열에서 일치하는 가장 첫번째 패턴 찾기 findall : 문자열에서 일치하는 모든 패턴 리스트 형태로 반환 split : 문자열에서 특정 패턴으로 나누기 sub 특정패텬에 맞는 문자열 대체하기 결과를 문자열로 다시 반환 두번째 인자는 특정 문자열 또는 함수 count가 0인 경우는 전체를, 1이상이면 해당 숫자만큼 치환 1re.sub(r'[\\w-]+@[\\w.]+', 'joy', 'happy@gmail.com great welcome@gmail.com nice thanks@gmail.com', count =2 1&apos;joy great joy nice thanks@gmail.com&apos; compile 동일한 정규표현식을 매번 다시 쓰기 번거로움을 해결 compile로 해당표현식을 re.RegexObject 객체로 저장하여 사용가능 12email_reg = re.compile(r'[\\w-]+@[\\w.]+')email_reg.search('lahong lahongkkito@gmail.com lahongkkito') 1&lt;re.Match object; span=(7, 28), match=&apos;lahongkkito@gmail.com&apos;&gt; Q. 카드 번호 찾기 1comment = \"저의 카드 번호는 1234-2331-1123-9485와 7384 1234 5432 1222와 73841234-5432 1222 입니다.\" A. 123456import repattern = \"([0-9]&#123;4&#125;)[- ]?([0-9]&#123;4&#125;)[- ]?([0-9]&#123;4&#125;)[- ]?([0-9]&#123;4&#125;)\"# print(re.findall(pattern, comment))re.sub(pattern, \"\\g&lt;1&gt;-\\g&lt;2&gt;-\\g&lt;3&gt;-****\", comment) 1&apos;저의 카드 번호는 1234-2331-1123-****와 7384-1234-5432-****와 7384-1234-5432-**** 입니다.&apos; Q. 숫자로 바꾸기 1s = \"안녕하세요, 저의 전화번호는 영일공-48구삼삼7이사 그리고 010사팔구삼삼구삼일 입니다. 둘중에 하나로 연락하세요\" A. 1234567891011121314151617import rep = \"[0-9영공일이둘삼셋사넷오육칠팔구빵oO]&#123;3&#125;[- ]?[0-9영공일이둘삼셋사넷오육칠팔구빵oO]&#123;3,4&#125;[- ]?[0-9영공일이둘삼셋사넷오육칠팔구빵oO]&#123;4&#125;\"dic = &#123; \"영\":0, \"공\":0, \"일\":1, \"이\":2, \"둘\":2, \"삼\":3, \"셋\":3, \"사\":4, \"넷\":4, \"오\":5, \"육\":6, \"칠\":7, \"팔\":8, \"구\":9, \"빵\":0, \"o\":0, \"O\":0,&#125;numbers = re.findall(p, s)result = []for num in numbers: for key, value in dic.items(): num = num.replace(key, str(value)) num = num.replace(\"-\", \"\") result.append(num)result 1[&apos;0104833724&apos;, &apos;01048952339&apos;] Q. 올바른 웹페이지 주소 찾기 12345678webs = ['http://www.test.co.kr', 'https://www.test1.com', 'http://www.test.com', 'ftp://www.test.com', 'http:://www.test.com', 'htp://www.test.com', 'http://www.google.com', 'https://www.homepage.com.'] A. 12web_reg = re.compile(r'https?://[\\w.]+\\w+$')list(map(lambda w:web_reg.search(w) != None, webs)) 1[True, True, True, False, False, False, True, False]","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[]},{"title":"07_Class","slug":"07-class","date":"2019-09-26T12:38:41.000Z","updated":"2019-10-06T03:41:00.785Z","comments":true,"path":"2019/09/26/07-class/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/26/07-class/","excerpt":"","text":"클래스 실제 세계를 모델링하여 공통적인 기능을 묶어 개발 객체(인스턴스) 식별성, 타입, 값을 지님 자신만의 함수를 가짐 확장성이 높아지는 장점(의존성은 낮아짐) 특성 다형성 : 같은 이름으로 함수를 실행할 때 아규먼트의 차이에 따라 다른 코드가 실행되게 하는 기능 (method overloading) 캡슐화 (은닉화) : 외부에 변수나 함수를 감춰 내용을 알지 못해도 기능 사용 가능 (nonpublic) 추상화 : 여러가지 요소를 하나로 통합해 사용자가 코드를 몰라도 사용 가능 self 객체 자신을 의미 클래스 내부의 함수 선언시 첫번째 parameter 현재 해당 메소드가 호출되는 객체 자신을 가리킴 C++/C#, Java의 this에 ㄷ해당 클래스 정의 후 객체, 함수 등을 추가 object 클래스로 생성되어 구체화된 객체 (인스턴스) 실제로 클래스가 인스천스화 되어 메모리에 상주하는 상태 의미 생성자 클래스가 다루는 데이터를 정의 (member variable, attribute) 클래스가 객체로 만들어질 때 초기값을 설정하는 기능 __init__으로 선언 필수 변수가 있어야 객체 생성 123456789101112131415# 계산기 클래스class Calulator: def __init__(self, *args, **kwargs): self.total = sum(args) self.plus = func self.num1 = kwargs[\"num1\"] self.num2 = kwargs[\"num2\"] def set_data(self, num1, num2): self.num1 = num1 self.num2 = num2 def add(self): return self.plus(self.num1 + self.num2) 123c1 = calculator(lambda *args: sum(args), 1, 2, 3, num1=10, num=20)c1.totalc1.add() 클래스 메서드 객체 레벨에서 호출 해당 객체의 속성에 대한 연산 수행 {obj}.{method}() 형태로 호출 instance method 인스턴스를 통해 호출해서 사용 호출한 객체에만 영향을 미침 self 파라미터 사용 self 객체를 받음 class method 클래스를 통해서 사용 클래스 멤버 변수만 변경 가능 cls 파라미터 사용 cls 클래스를 받음 static method 클래스 안에서 선언되는 일반 함수 magic(special) method 클래스에서 객체로 만들어질 떄, 자동 생성 함수 객체 사이의 연산자 사용과 같은 코드 정의 파이썬 내장 함수나 연산자 적용 가능 compare __eq__ : == __ne__ : != __lt__ : &lt; __gt__ : &gt; __le__ : &lt;= __ge__ : &gt;= calculate __add__ : + __sub__ : - __mul__ : * __truediv__ : / __floordiv__ : // __mod__ : % __pow__ : ** __repr__ __str__ __len__ 상속 기존에 정의한 클래스이 기능을 그대로 물려받아 새로운 변수나 함수를 추가/수정 가능 부모 클래스 (Parent, Super, Base class) : 상속 받고자 하는 기존 클래스 자식 클래스 (Child, Sub, Derived class) : 상속 받는 새로운 클래스 is a : A is a B와 같은 의미로 상속 사용해서 클래스 선언 has a : B has a A 클래스의 변수를 객체로 받아 객체 생성 123456class ImprovedCalculator(Calculator): def pow_func(self): return self.num1 ** self.num2ic = ImprovedCalculator(2, 3)ic.add(), ic.pow_func() 다중상속 super 부모클래스의 변수나 함수를 받아올 때 사용 부모클래스의 생성자를 다시 선언시 사용 다이아몬드 상속시 중복 생성자 상속 방지 overiding 부모클래스가 가지고 있던 함수를 다시 정의해서 사용 overloading 함수의 이름은 같으나 argument의 갯수 차이로 다른 코드 실행 123456789101112131415161718192021222324252627282930313233343536373839class Human: def __init__(self): self.health = 40 def set_health(self, var): self.health += var if self.health &gt; 40: self.health = 40 elif self.health &lt; 0: self.health = 0class Marin(Human): def __init__(self, attack_pow=5, kill=0): super(Marin, self).__init__() self.attack_pow = attack_pow self.kill = kill def attack(self, obj): if obj.health == 0: print(\"already die\") return obj.set_health(-self.attack_pow) if obj.health &lt;= 0: self.kill +=1 print(\"kill\")class Medic(Human): def __init__(self, heal_pow=6): super(Medic, self).__init__() self.heal_pow = heal_pow def heal(self, obj): if obj.health == 0: print(\"already die\") return obj.set_health(self.heal_pow) 12345marin1 = Marin()marin2 = Marin()medic1 = Medic()marin1.attack(marin2)medic.heal(marin1) Getter &amp; Setter 객체 내부 변수에 접근할 때 특정 로직을 거쳐 접근할 수 있도록 하는 방법 getter : 속성 값을 가져오는 메서드 setter : 값을 저장하는 메서드 메서드를 속성처럼 사용할 수 있음 property1234567891011121314class Person1: def __init__(self): self.__age = 0 def get_age(self): # getter return self.__age def set_age(self): # setter self.__age = valuejason = Person1()jason.set_age(15)print(jason.get_age()) decolator12345678910111213141516class Person2: def __init__(self): self.__age = 0 @property def age(self): # getter return self.__age @age.setter def age(self, value): # setter self.__age = valuesumi = Person2()sumi.age = 23print(sumi.age) non public (private) magling 방법으로 구현 class 내부 변수에 직접 접근 불가 __를 붙여 변수 선언 (객체명)._(클래스명)(변수명)으로 접근 가능","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"class","slug":"class","permalink":"https://Lahongkkito.github.io/tags/class/"},{"name":"객체지향","slug":"객체지향","permalink":"https://Lahongkkito.github.io/tags/객체지향/"},{"name":"decorator","slug":"decorator","permalink":"https://Lahongkkito.github.io/tags/decorator/"}]},{"title":"06_module","slug":"06-module","date":"2019-09-21T16:43:00.000Z","updated":"2019-10-06T03:40:50.053Z","comments":true,"path":"2019/09/22/06-module/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/22/06-module/","excerpt":"","text":"Module 변수, 함수, 클래스를 모아 놓은 하나의 파이썬 파일 (.py) 파일 단위로 코드 분리해서 관리 식별자 사용 규칙 짧은 소문자 사용 합성어 사용시 snake_case, CamelCase 구분 사용 모듈 명 가장 앞에 _ 붙은 경우 C, C++ 언어로 작성된 코드 예 : requests, numpy, pandas, math 모듈 호출 해당 모듈 전체 import from : 해당 모듈에서 특정한 타입만 import * : 해당 모듈 내 정의된 모든 것 import (비권장) as : alias 지정 Package 디렉토리와 모듈로 구성 __init__ 파일 필요 디렉토리 생성 1!mkdir -p study/drawing init 파일 추가 1!touch study/drawing/__init__.py 모듈 작성 1%%writefile study/drawing/lahong.py 호출 1import study.drawing.lahong as lh 설치 12345678910111213%%writefile study/setup.pyfrom setuptools import setup, find_packagessetup( name='learn', packages=find_packages(), include_package_data=True, version='0.0.1', author='Lahongkkito', author_email='lahongkkito@gmail.com', zip_safe=False,) study $ python setup.py develop develop (개발자 모드) : 코드 수정시 설치된 패키지도 수정된 내용이 적용 build (일반 모드) : 코드 수정시 설치된 패키지가 수정되지 않습니다.","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"module","slug":"module","permalink":"https://Lahongkkito.github.io/tags/module/"},{"name":"writefile","slug":"writefile","permalink":"https://Lahongkkito.github.io/tags/writefile/"},{"name":"import","slug":"import","permalink":"https://Lahongkkito.github.io/tags/import/"}]},{"title":"05_function","slug":"05-function","date":"2019-09-20T22:31:17.000Z","updated":"2019-10-06T03:40:05.638Z","comments":true,"path":"2019/09/21/05-function/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/21/05-function/","excerpt":"","text":"함수 기본함수함수명 (파라미터2, 파라미터2, ...) 반복되는 코드를 묶음으로 효율적으로 코드를 작성 def : 함수 선언 return 결과 반환 값 지정 함수의 종료 명시 return만 존재하면 None 반환 mutiple return 가능 parameter 함수에 전달되는 입력(input) default parameter : 기본 인자 가장 뒤에 선언 argument 함수에 입력으로 전달하는 값 함수에 파라미터 개수가 불특정할 때 사용 가능 *args 함수 호출시 여러개의 데이터를 한꺼번에 받아올 때 사용 파라미터를 튜플 형태로 전달 **kwargs 함수 호출시 여러개의 키워드 데이터를 받아올 떄 사용 파라미터를 딕셔너리 형태로 전달 Docstring 함수에 대한 설명 &lt;함수명&gt;? &lt;함수명&gt;?? help(함수명) print(함수명.doc) dir(함수명) 123def echo(msg): \"inpur docstring here !\" return msg Scope global variable : 전역변수 가장 상단에서 정의되어 프로그램 종료 전까지 유지 상수(변수명 대문자 표기)를 주로 선언해서 사용 local variable: 지역변수 특정 코드 블록에서 선언된 변수 같은 이름의 경우 전역변수보다 우선순위 높음 Inner Function 함수 안에서 선언된 함수 자원을 효율적으로 사용 지역함수 Lambda Function 단일문으로 표현되는 익명함수 파라미터를 받아 바로 리턴하는 함수를 줄여서 작성 리소스를 적게 사용 (1회성) 12345def test(func, *args, **kwargs): print(args) print(kwargs)test(lambda x: x**2, 1, 2, 3, who=\"Robert\", what=\"IronMan\") 12(1, 2, 3)&#123;&apos;who&apos;: &apos;Robert&apos;, &apos;what&apos;: &apos;IronMan&apos;&#125; Map, Reduce, Filter map : 리스트 데이터의 각 요소에 함수를 실행하고 나온 결과를 새로운 리스트로 반환 filter : 특정 조건을 만족시키는 요소만 남기는 함수 reduce : 차례대로 앞 2개의 원소 연산 결과가 다음 연산의 입력으로 진행되어 최종 출력이 한개 1234567891011121314151617names = [\"Kim python\", \"lee summer\", \"Park soojin\", \"Kim data\", \"Lee campus\", \"HONG Lahong\"]# Q1. map을 이용하여 name의 성만 출력result1 = list(map(lambda name : name.split(\" \")[0].upper()[0] + name.split(\" \")[0].lower[1:], names))# Q2. filter 이용해서 성이 Kim인 사람의 이름만 결과로 출력family_name = \"Kim\"result2 = list(filter(lambda name : name.split(\" \")[0] == family_name, names))# Q3. reduce를 이용하여 사람 이름의 길이가 가장 긴사람 1명을 출력from functools import reduceresult3 = reduce(lambda name1, name2 : name1 if len(name1) &gt; len(name2) else name2, names) 123result1 = [&apos;Kim&apos;, &apos;Lee&apos;, &apos;Park&apos;, &apos;Kim&apos;, &apos;Lee&apos;, &apos;Hong&apos;]result2 = [&apos;Kim python&apos;, &apos;Kim data&apos;]result3 = &apos;HONG Lahong&apos; Decorator 코드를 바꾸지 않고 함수의 기능 추가 및 수정 가능 함수에서 공통된 코드 부분을 따로 묶어 관리할 수 있는 장점 지역함수와 args, *kwargs 구현 Q. 데코레이터 함수를 이용해서 함수에 미리 저장된 아이디를 입력하면 패스워드를 알려주는 코드를 작성하세요. A. 12345678910111213141516171819admin_ls = [\"IronMan\", \"Thor\"]pw = \"Avengers\"def admin(func): def wrapper(*args, **kwargs): is_admin = False result = func(*args, **kwargs) if result in admin_ls: print(\"allow permission!\") print(\"Pw: \", pw) is_admin = True else: print(\"Not admin!\") return is_admin return wrapper@admindef input_id(): return input(\"Insert ID: \") 1234# input_id()= &quot;Lahong&quot;Insert ID: LahongNot admin!False 12345# input_id()= &quot;IronMan&quot;Insert ID: IronManallow permission!Pw: AvengersTrue","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"https://Lahongkkito.github.io/tags/lambda/"}]},{"title":"04_loops","slug":"04-loops","date":"2019-09-19T15:01:02.000Z","updated":"2019-10-06T03:39:52.142Z","comments":true,"path":"2019/09/20/04-loops/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/20/04-loops/","excerpt":"","text":"반복문 반복적 작업을 위한 도구로 코드 작업에서 가장 많이 사용하는 구문 중 하나 특정 조건을 만족하는 경우 수행 (while) 리스트, 문자열, 튜플 등 컬렉션 타입의 아이템을 하나씩 순회하면서 사용 (for) break : 특정 조건일때 종료 주의 : while을 사용할 경우, 반복을 멈추게 하는 장치가 필요 반복문 중단 이후 코드 수행 continue : 해당 아이템 건너 뛰고 다음 반복 실행 중첩 사용 가능 (외부 루트 수행 횟수 만큼 내부 루프 반복 수행) for iterable한 집합의 아이템(데이터)을 value 변수에 차례로 대입 후 for 구문 코드 실행 모든 아이템이 순회되면 for 블록 종료 문자열의 경우 리스트와 유사하게 순회 12for value in &lt;iterable&gt; : &lt;code : value&gt; dict 아이템 출력 가능 keys(), values(), items() 123a = &#123;'korea': 'seoul', 'japan': 'tokyo', 'canada': 'ottawa'&#125;for key, value in a.items():print(key, value) 123korea seouljapan tokyocanada ottawa range iterable 숫자로 구성된 리스트 데이터를 만드는 함수 range(end) range(start, end) range(start, end, stride) enumerate index와 value 값을 동시에 사용 (tuple 형태로 반환) 123subjects = [\"math\", \"english\", \"science\",]for number, value in enumerate(subjects): print(number + 1, value) 1((0, &apos;math&apos;), (1, &apos;english&apos;), (2, &apos;science&apos;)) zip 리스트를 같은 index끼리 묶어주는 함수 1234subjects = [\"math\", \"english\", \"science\",]points = [80, 90, 70]grades = [\"B\", \"A\", \"C\"]list(zip(subjects, points, grades)) 1[(&apos;math&apos;, 80, &apos;B&apos;), (&apos;english&apos;, 90, &apos;A&apos;), (&apos;science&apos;, 100, &apos;A&apos;)] list comprehension 반복문의 결과를 바로 리스트로 만듦으로써 for문 보다 속도가 빠르다. 조건문, 삼항연산 등과 함께 사용 가능 ls = [&lt;value&gt; for &lt;value&gt; in &lt;list&gt;]ls = [&lt;value&gt; for &lt;value&gt; in &lt;list&gt; if &lt;condition&gt;] Q. 삼항연산으로 1~10의 숫자와 홀/짝수 구분을 출력하세요.A. 1234ls = [ str(num) + \":even\" if num % 2 == 0 else str(num) + \":odd\" for num in range(1, 11)] while condition이 False가 될 때까지 구문 실행 12345678910111213a = [1, 2, 3, 4, 5, 'q']idx = 0while True: data = a[idx] idx += 1 if data == 'q': break elif data % 2 == 0 : continue print(data) 123135","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"for","slug":"for","permalink":"https://Lahongkkito.github.io/tags/for/"},{"name":"while","slug":"while","permalink":"https://Lahongkkito.github.io/tags/while/"},{"name":"break","slug":"break","permalink":"https://Lahongkkito.github.io/tags/break/"},{"name":"list comprehension","slug":"list-comprehension","permalink":"https://Lahongkkito.github.io/tags/list-comprehension/"}]},{"title":"03_conditions","slug":"03-conditions","date":"2019-09-19T06:57:42.000Z","updated":"2019-10-06T03:39:31.803Z","comments":true,"path":"2019/09/19/03-conditions/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/19/03-conditions/","excerpt":"","text":"조건문 if, elif, else indentation(들여쓰기) 사용 nesting(반복 중첩) 가능 (비권장) boolean으로 표현 논리식 AND, OR, NOT 사용 가능 우선순위 NOT &gt; AND &gt; OR 예외 : 기본 타입 사용 가능 False 간주 값 (각 타입 기본값) None, 0, 0.0, “, (), [], {}, set() 이 외 모두 True Q. 숫자를 입력받아 아래 조건에 맞게 결과를 출력하세요. 3의 배수이면 fizz 5의 배수이면 buzz 15의 배수이면 fizzbuzz 이 외의 경우 입력받은 숫자 A. 12345678910num = int(input(\"Insert number: \"))if num % 15 ==0 : print(\"fizzbuzz\")elif num % 5 ==0 : print(\"buzz\")elif num % 3 ==0 : print(\"fizz\")else: print(num) 123456if num % 3 ==0 : print(\"fizz\", end=\"\")elif num % 5 ==0 : print(\"buzz\")if not((num % 3 ==0) or (num % 5 ==0)): print(num) 삼항연산 condition이 True이면 A를 리터, False니면 B를 리턴 A if (condition) else B Q. 숫자를 입력받아 짝수이면 “even”, 홀수이면 “odd”를 출력하세요. A. 12num = int(input(\"Insert number: \"))\"even\" if num % 2 == 0 else \"odd\" 예외처리 try, except 예외 변수 지정 모든 예외 검출 Exception 클래스를 상속 123456ls = [1, 2, 3]try: # 5/0 # ls[4]except Exception as e: print(e) finally : try-except 구문 완료 후 실행 raise : 에러를 발생시키는 예약어로 코드 실행이 중단됨 12345try: 5/0except Exception as e: print(e) raise(e) Q. 이자율 이자율 입력시 1.03미만 또는 1.10 초과일 경우 메세지와 에러발생 __str__ : 오류 메세지를 print문으로 출력할 때 호출되는 메서드1234567891011121314151617181920212223class LowInter(Exception): def __str__(self): return \"이자율을 1.03이상으로 설정\"class HighInter(Exception): def __str__(self): return \"이자율을 1.10이하로 설정\"class Account: def __init__(self, interest): if interest &lt; 1.03: raise LowInter() elif interest &gt; 1.10: raise HighInter() else: self.interest = interest def disp(self): interest = round((self.interest - 1)*100, 1) return \"계좌 설정 이자율은 &#123;&#125;%\".format(interest)","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"if","slug":"if","permalink":"https://Lahongkkito.github.io/tags/if/"},{"name":"삼항연산","slug":"삼항연산","permalink":"https://Lahongkkito.github.io/tags/삼항연산/"},{"name":"try","slug":"try","permalink":"https://Lahongkkito.github.io/tags/try/"},{"name":"exception","slug":"exception","permalink":"https://Lahongkkito.github.io/tags/exception/"}]},{"title":"02_operators","slug":"02-operators","date":"2019-09-17T05:51:58.000Z","updated":"2019-10-06T03:39:17.126Z","comments":true,"path":"2019/09/17/02-operators/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/17/02-operators/","excerpt":"","text":"연산자 산술연산자+, -, *, /, //, %, ** 부동소수점 0.1 + 0.2 = 0.30000000000000004 해결 1 유효숫자 지정 (반올림) round(2.2) = 2 round(-3.8) = -4 해결 2 고정소수점 연산 : 십진법 연산 모듈, str 객체 생성, int 연산 가능 from decimal import Decimal float(Decimal(‘0.1’) + Decimal(‘0.2’)) = 0.3 해결 3 : fraction (분자, 분모) int/float 연산 가능 import fractions fractions.Fraction(5, 30) = Fraction(1, 6) fractions.Fraction(0.75) = Fraction(3, 4) a = fractions.Fraction(9, 28) a.numerator = 9 a.denominator = 28 해결 4 : math 모듈 import math math.ceil(4.3) = 5 비교연산자==, !=, &gt;, &lt;, &lt;=, &gt;= 할당연산자=, +=, -=, *=, /=, //=, %=, **= 비트연산자 2진수 연산 방식 bin() : 이진수 문자열로 변환 bin(5) = 0b101 0b10110 = 22 int(‘11101’, 2) = 29 &amp; : bit 단위로 and 연산 | : bit 단위로 or 연산 ^ : bit 단위로 xor 연산 ~ : bit 단위로 not 연산 (1의 보수) &lt;&lt;/&gt;&gt; bit 단위로 왼/오른쪽 비트단위 밀기 연산 양수는 0, 음수는 1 채워짐 왼쪽/오른쪽 shift 마다 2^n 곱한/나눈 효과 bin(0b10101 &amp; 0b11100) = 0b101000b10101 &amp; 0b11100 = 28 &amp; 21 = 20 bin(0b10101 | 0b11100) = 0b111010b10101 | 0b11100 = 28 | 21 = 29 bin(0b10101 ^ 0b11100) = 0b10010b10101 ^ 0b11100 = 28 ^ 21 = 9 bin(~0b10101) = -0b10110~0b10101 = -22~28 = -29 논리연산자 and : 둘 다 참일 때 참 or : 둘 중 하나 참일 때 참 not : 참이면 거짓, 거짓이면 참 멤버연산자 in : list 내에 포함되어 있으면 참 not in : list 내에 포함되어 있지 않으면 참 식별연산자 is : 개체메모리 위치나 값이 같으면 참 is not : 개체메모리 위치나 값지 않으면 참","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[]},{"title":"01_datatype","slug":"01-datatype","date":"2019-09-16T08:15:28.000Z","updated":"2019-10-06T03:39:01.999Z","comments":true,"path":"2019/09/16/01-datatype/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/16/01-datatype/","excerpt":"","text":"종류 Numbers 정수형 : int 실수형(소수) : float 복소수 : complex (2+3j) 123a, b, c, d, e, f = 5, 0.12, -6.0, -6, 0, 0.0type(a), type(b), type(c), type(d), type(e), type(f)(int, float, float, int, int, float) Boolean True/False 0을 제외한 숫자 True, 문자 True String1s = \"AaBb ccc DD \" 문자열 &quot;, &#39; 구분없이 사용 &quot;&quot;&quot;, &#39;&#39;&#39; 세 개 사용으로 멀티라인 escape string \\n: new line \\t: tap 대문자/소문자 변환 함수 12s.upper() = 'AABB CCC DD 's.lower() = 'aabb ccc dd ' 해당 값의 위치 찾기 12s.find(\"ccc\") = 5 # 중복될 경우 가장 처음, 없을 경우 -1 반환s.index(\"b\") = 3 # 없을 경우 error 포함된 개수 리턴 1s.count(\"x\") = 0 공백 제거 123s.lstrip() = 'AaBb ccc DD ' # 왼쪽 공백 제거s.rstrip() = 'AaBb ccc DD' # 오른쪽 공백 제거s.strip() = 'AaBb ccc DD' # 양쪽 공백 제거 문자열 변환 12s.replace(\"c\", \"k\") = 'AaBb kkk DD 's.replace(\" \", \"\") = s.replace(\" \", \"\") # 중간 공백 제거 가능 체이닝 123s = \"this is a peach!!\"s.endswith(\"peach!!\") = Trues.endswith(\"peach\") = False string format 123a, b = 123, \"python\"\"&#123;&#125;,&#123;&#125;\".format(a, b)) = '123, python'\"&#123;str_&#125;, &#123;num&#125;\".format(num=a, str_=b)) = 'python, 123' List1ls = ['a', 100, [1, \"k\"]] iterable 여러 자료형 함께 저장 가능 수열 리스트 12list(range(5)) = [0, 1, 2, 3, 4]list(range(3, 10, 2)) = [3, 5, 7, 9] 자료 수정 12ls[1] = 50ls = ['a', 50, [1, \"k\"]] 자료 추가 123ls.append(\"plus\") = ['a', 100, [1, 'k'], 'plus']ls.insert(0, \"insert\") = ['insert', 'a', 100, [1, 'k'], 'plus'] 자료 삭제 123ls.pop() = 'plus'ls.remove('a') = [100, [1, 'k']] # index 값이 가장 작은 데이터 한개만 삭제del ls[2] = ['a', 100] 졍렬 ls.sort() # 동일한 타입의 경우만 가능 ls.sort(key=len) ls.reverse() offset 인덱스/슬라이싱 1234567slic = \"I want some TTEOKBOKKI!\"`slic[7:11] = 'some'slic[3:15:2] = 'atsm TOBK'slic[::2] = 'Iwn oeTEKOK!'slic[::-1] = '!IKKOBKOETT emos tnaw I'slic.split(\"O\") = ['I want some TTE', 'KB', 'KKI!'] 복사 얕은복사 : 주소값만 복사 깊은복사 : 메모리 복사 5) Tuple iterable 데이터 수정 불가능 리스트보다 적은 메모리 사용123456tp1 = 1, 2, 3tp2 = \"a\", \"b\"tp3 = (1, \"b\")tp1, tp2, tp3, type(tp1)((1, 2, 3), ('a', 'b'), (1, 'b'), tuple) 6) Dictionary 데이터 순서 없음 key 내부적으로 hash값으로 지정 str,int만 가능 key : value {key1:value2, key2:value2} 123456dic = &#123; 1: \"one\", \"A\": [\"data\", \"python\"], \"숫자\": 1234, 2: \"two\",&#125; 호출 1234567dic.keys() = dict_keys([1, 'A', '숫자', 2])dic.values() = dict_values(['one', ['data', 'python'], 1234, 'two'])dic.items() = dict_items([(1, 'one'), ('A', ['data', 'python']), ('숫자', 1234), (2, 'two')])dic.get(\"A\") = ['data', 'python']dic[\"숫자\"] = 12342 in dic = False\"two\" in dic = True # key값 존재 확인 자료 추가 12dic[\"key3\"] = 40dic = &#123;1: 'one', 'A': ['data', 'python'], '숫자': 1234, 2: 'two', 'key3': 40&#125; 자료 삭제 12del dic[\"key3\"]dic.clear() = &#123;&#125; update (덮어쓰기) 1234dic1 = &#123;1: \"a\", 2: \"b\"&#125;dic2 = &#123;3: \"d\", 2: \"c\"&#125;dic1.update(dic2)dic1 = &#123;1: 'a', 2: 'c', 3: 'd'&#125; 7) Set 중복 데이터 없음 교집합, 합집합, 차집합 연산 가능 수정 불가능(리스트 형변환) 12a_set = set([\"A\", \"B\", \"C\", \"D\",])b_set = set([\"C\", \"D\", \"E\", \"F\", \"G\",]) 합집합 a_set | b_set a_set.union(b_set) 교집합 a_set &amp; b_set a_set.intersection(b_set) 차집합 a_set - b_set a_set.difference(b_set) 대칭차집합 a_set ^ b_set 부분집합 a_set.issubset(b_set) = False 데이터 타입 변경문자/숫자 변환12string = \"1234\"number = int(string) boolean형 변환12bool(\"\"), bool(\"data\"), bool(-1), bool(0), bool(23)(False, True, True, False, True ) 문자열/리스트 변환1234567string = \"ABCD\"ls = [ 3,\"f\",\"g\",]list(string) = ['A', 'B', 'C', 'D']str(ls) = \"[3, 'f', 'g'] # 문장의 경우 string.split(\" \") 또는 \" \".join(ls)로 가능 튜플/딕셔너리 변환12345tp = ((1,\"one\"),(2,\"two\"))dic = &#123;3:\"three\", 4:\"four\"&#125;dict(tp) = &#123;1: 'one', 2: 'two'&#125;tuple(dic) = (3, 4)","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"datatype","slug":"datatype","permalink":"https://Lahongkkito.github.io/tags/datatype/"},{"name":"string","slug":"string","permalink":"https://Lahongkkito.github.io/tags/string/"},{"name":"list","slug":"list","permalink":"https://Lahongkkito.github.io/tags/list/"},{"name":"tuple","slug":"tuple","permalink":"https://Lahongkkito.github.io/tags/tuple/"},{"name":"set","slug":"set","permalink":"https://Lahongkkito.github.io/tags/set/"}]},{"title":"00_basic","slug":"00-basic","date":"2019-09-16T08:10:06.000Z","updated":"2019-10-06T03:37:46.413Z","comments":true,"path":"2019/09/16/00-basic/","link":"","permalink":"https://Lahongkkito.github.io/2019/09/16/00-basic/","excerpt":"","text":"Python Basic Syntax PEP PEP20 : 파이썬의 정신, 철학, 혼 PEP8 : 파이썬 코딩 스타일 가이드 1import this The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren’t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one– and preferably only one –obvious way to do it.Although that way may not be obvious at first unless you’re Dutch.Now is better than never.Although never is often better than right now.If the implementation is hard to explain, it’s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea – let’s do more of those! comment (주석) 가장 앞에 #을 붙이면 해당 라인의 코드는 실행 되지 않음 테스트를 위해 중간에 코드를 실행하지 않거나 코드에 대한 간략한 설명을 할때 사용 단축키 cmd(ctrl) + / 변수 변수를 선언하면 메모리에 데이터를 저장하기 위한 저장공간 생성 식별자 변수, 함수, 클래스, 모듈 등을 구분하기 위해서 사용하는 이름 대소문자 구분 _를 제외한 특수문자 사용 불가 가장앞에 __ 사용은 지양 가장앞에 숫자 사용 불가능 예약어(for, while, if, class 등) 사용 불가능 변수, 함수 : 소문자 스네이크 케이스 (snake_case) 클래스 : 대문자 카멜 케이스 (CamelCase) print (출력) 해당 변수의 값을 출력 , 로 여러 변수를 나열하면 한줄에 출력 기본적으로 한칸 띄어쓰기 후 출력1234a = 4b = 7print(a, b, 10, 100, sep='*', end='!!') = 4*7*10*100!!","categories":[{"name":"Python","slug":"Python","permalink":"https://Lahongkkito.github.io/categories/Python/"}],"tags":[{"name":"PEP","slug":"PEP","permalink":"https://Lahongkkito.github.io/tags/PEP/"}]}]}